Push(x) : Inserts x at the top of stack.

If stack is empty, insert x into the stack and make minEle equal to x.
If stack is not empty, compare x with minEle. Two cases arise:
If x is greater than or equal to minEle, simply insert x.
If x is less than minEle, insert (2*x – minEle) into the stack and make
minEle equal to x. For example, let previous minEle was 3. Now we want to insert 2.
We update minEle as 2 and insert 2*2 – 3 = 1 into the stack.


Pop() : Removes an element from top of stack.

Remove element from top. Let the removed element be y. Two cases arise:
If y is greater than or equal to minEle, the minimum element in the stack is still minEle.
If y is less than minEle, the minimum element now becomes (2*minEle – y),
so update (minEle = 2*minEle – y). This is where we retrieve previous minimum 
from current minimum and its value in stack.

# GFG reference 
class Node: 
	# Constructor which assign argument to nade's value 
	def __init__(self, value): 
		self.value = value 
		self.next = None

	def __str__(self): 
		return "Node({})".format(self.value) 
	
	# __repr__ is same as __str__ 
	__repr__ = __str__ 


class Stack: 
	def __init__(self): 
		self.top = None
		self.count = 0
		self.minimum = None
		
	def __str__(self): 
		temp = self.top 
		out = [] 
		while temp: 
			out.append(str(temp.value)) 
			temp = temp.next
		out = '\n'.join(out) 
		return ('Top {} \n\nStack :\n{}'.format(self.top,out)) 
		
	__repr__=__str__ 
	
	def getMin(self): 
		if self.top is None: 
			return "Stack is empty"
		else: 
			print("Minimum Element in the stack is: {}" .format(self.minimum)) 
 
	def isEmpty(self): 
		# If top equals to None then stack is empty 
		if self.top == None: 
			return True
		else: 
		# If top not equal to None then stack is empty 
			return False

	def __len__(self): 
		self.count = 0
		tempNode = self.top 
		while tempNode: 
			tempNode = tempNode.next
			self.count+=1
		return self.count 

	def peek(self): 
		if self.top is None: 
			print ("Stack is empty") 
		else: 
			if self.top.value < self.minimum: 
				print("Top Most Element is: {}" .format(self.minimum)) 
			else: 
				print("Top Most Element is: {}" .format(self.top.value)) 

	def push(self,value): 
		if self.top is None: 
			self.top = Node(value) 
			self.minimum = value 
		
		elif value < self.minimum: 
			temp = (2 * value) - self.minimum 
			new_node = Node(temp) 
			new_node.next = self.top 
			self.top = new_node 
			self.minimum = value 
		else: 
			new_node = Node(value) 
			new_node.next = self.top 
			self.top = new_node 
		print("Number Inserted: {}" .format(value)) 

	# This method is used to pop top of stack 
	def pop(self): 
		if self.top is None: 
			print( "Stack is empty") 
		else: 
			removedNode = self.top.value 
			self.top = self.top.next
			if removedNode < self.minimum: 
				print ("Top Most Element Removed :{} " .format(self.minimum)) 
				self.minimum = ( ( 2 * self.minimum ) - removedNode ) 
			else: 
				print ("Top Most Element Removed : {}" .format(removedNode)) 
stack = Stack() 

stack.push(3) 
stack.push(5) 
stack.getMin() 
stack.push(2) 
stack.push(1) 
stack.getMin()	 
stack.pop() 
stack.getMin() 
stack.pop() 
stack.peek() 
